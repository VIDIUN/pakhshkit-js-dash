{"version":3,"sources":["./dash/webpack/universalModuleDefinition","./dash/pakhshkit-dash.js","./dash/webpack/bootstrap ce63100370231764307a","./dash/external {\"commonjs\":\"pakhshkit-js\",\"commonjs2\":\"pakhshkit-js\",\"amd\":\"pakhshkit-js\",\"root\":[\"pakhshkit\",\"core\"]}","./dash/external {\"commonjs\":\"shaka-player\",\"commonjs2\":\"shaka-player\",\"amd\":\"shaka-player\",\"root\":\"shaka\"}","./dash/./index.js","./dash/./dash-adapter.js","./dash/./drm/widevine.js","./dash/./drm/playready.js","./dash/./default-config.json","./dash/./text-displayer.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_0__","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","value","NAME","VERSION","undefined","_pakhshkitJs","_dashAdapter","_dashAdapter2","obj","default","isSupported","registerMediaSourceAdapter","_interopRequireDefault","_defineProperty","key","writable","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","_get","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","_createClass","defineProperties","target","props","length","descriptor","protoProps","staticProps","_shakaPlayer","_shakaPlayer2","_widevine","_widevine2","_playready","_playready2","_defaultConfig","_defaultConfig2","_textDisplayer","_textDisplayer2","ShakaEvent","ERROR","ADAPTATION","BUFFERING","DashAdapter","_BaseMediaSourceAdapt","videoElement","source","_this$_adapterEventsB","config","arguments","_logger","debug","Player","version","_this","_adapterEventsBindings","event","_onError","_onAdaptation","_onBuffering","EventType","WAITING","_onWaiting","PLAYING","_onPlaying","_buffering","_waitingSent","_playingSent","VIDEO_ERROR_CODE","_setShakaConfig","dashConfig","Utils","hasPropertyPath","playback","options","html5","dash","mimeType","canPlayType","toLowerCase","_dashMimeType","toString","drmData","canPlayDrm","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","_drmProtocols","Symbol","iterator","next","done","drmProtocol","_drmProtocol","err","return","resetVttPolyfill","window","VTTCue","polyfill","installAll","isBrowserSupported","textDisplayerConfig","textDisplayFactory","videoEl","bind","_videoElement","_config","mergeDeep","_shaka","_maybeSetDrmConfig","configure","setTextTrackVisibility","_addBindings","_sourceObj","setDrmPlayback","addEventListener","adaptation","error","buffering","waiting","playing","removeEventListener","startTime","_this2","_loadPromise","_init","Promise","resolve","reject","url","_trigger","ABR_MODE_CHANGED","mode","isAdaptiveBitrateEnabled","shakaStartTime","load","then","data","tracks","_getParsedTracks","catch","Error","severity","category","code","_this3","_removeBindings","destroy","variantTracks","getVariantTracks","activeVariantTrack","filter","variantTrack","active","audioId","videoId","videoTracks","_getParsedVideoTracks","audioTracks","_getParsedAudioTracks","textTracks","_getParsedTextTracks","concat","_getVideoTracks","parsedTracks","settings","id","bandwidth","width","height","index","push","VideoTrack","_getAudioTracks","label","language","AudioTrack","getTextTracks","kind","TextTrack","videoTrack","selectedVideoTrack","abr","enabled","selectVariantTrack","_onTrackChanged","audioTrack","selectAudioLanguage","textTrack","selectTextLanguage","getConfiguration","seekRange","end","NaN","currentTime","isLive","detail","dispatchEvent","Event","paused","start","BaseMediaSourceAdapter","getLogger","DrmSupport","BaseDrmProtocol","DrmScheme","Widevine","_BaseDrmProtocol","apply","WIDEVINE","isProtocolSupported","browser","Env","wwDrmEntry","find","drmEntry","scheme","drm","servers","licenseUrl","advanced","videoRobustness","audioRobustness","PlayReady","PLAYREADY","prDrmEntry","streaming","ignoreTextStreamFailures","TextDisplayer","_shaka$text$SimpleTex","text","SimpleTextDisplayer"],"mappings":"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","file":"pakhshkit-dash.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"pakhshkit-js\"), require(\"shaka-player\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"pakhshkit-js\", \"shaka-player\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"dash\"] = factory(require(\"pakhshkit-js\"), require(\"shaka-player\"));\n\telse\n\t\troot[\"pakhshkit\"] = root[\"pakhshkit\"] || {}, root[\"pakhshkit\"][\"dash\"] = factory(root[\"pakhshkit\"][\"core\"], root[\"shaka\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"pakhshkit-js\"), require(\"shaka-player\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"pakhshkit-js\", \"shaka-player\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"dash\"] = factory(require(\"pakhshkit-js\"), require(\"shaka-player\"));\n\telse\n\t\troot[\"pakhshkit\"] = root[\"pakhshkit\"] || {}, root[\"pakhshkit\"][\"dash\"] = factory(root[\"pakhshkit\"][\"core\"], root[\"shaka\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NAME = exports.VERSION = undefined;\n\nvar _pakhshkitJs = __webpack_require__(0);\n\nvar _dashAdapter = __webpack_require__(3);\n\nvar _dashAdapter2 = _interopRequireDefault(_dashAdapter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _dashAdapter2.default;\nexports.VERSION = \"1.6.2\";\nexports.NAME = \"pakhshkit-js-dash\";\n\n// Register DashAdapter to the media source adapter manager\n\nif (_dashAdapter2.default.isSupported()) {\n  (0, _pakhshkitJs.registerMediaSourceAdapter)(_dashAdapter2.default);\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _shakaPlayer = __webpack_require__(1);\n\nvar _shakaPlayer2 = _interopRequireDefault(_shakaPlayer);\n\nvar _pakhshkitJs = __webpack_require__(0);\n\nvar _widevine = __webpack_require__(4);\n\nvar _widevine2 = _interopRequireDefault(_widevine);\n\nvar _playready = __webpack_require__(5);\n\nvar _playready2 = _interopRequireDefault(_playready);\n\nvar _defaultConfig = __webpack_require__(6);\n\nvar _defaultConfig2 = _interopRequireDefault(_defaultConfig);\n\nvar _textDisplayer = __webpack_require__(7);\n\nvar _textDisplayer2 = _interopRequireDefault(_textDisplayer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Shaka events enum\r\n * @type {Object}\r\n * @const\r\n */\nvar ShakaEvent = {\n  ERROR: 'error',\n  ADAPTATION: 'adaptation',\n  BUFFERING: 'buffering'\n};\n\n/**\r\n * Adapter of shaka lib for dash content\r\n * @classdesc\r\n */\n\nvar DashAdapter = function (_BaseMediaSourceAdapt) {\n  _inherits(DashAdapter, _BaseMediaSourceAdapt);\n\n  _createClass(DashAdapter, null, [{\n    key: 'createAdapter',\n\n\n    /**\r\n     * Factory method to create media source adapter.\r\n     * @function createAdapter\r\n     * @param {HTMLVideoElement} videoElement - The video element that the media source adapter work with.\r\n     * @param {PKMediaSourceObject} source - The source Object.\r\n     * @param {Object} config - The player configuration.\r\n     * @returns {IMediaSourceAdapter} - New instance of the run time media source adapter.\r\n     * @static\r\n     */\n\n    /**\r\n     * Whether 'playing' event has been sent by the HTMLVideoElement\r\n     * @member {boolean} - _playingSent\r\n     * @type {boolean}\r\n     * @private\r\n     */\n\n    /**\r\n     * The buffering state flag\r\n     * @member {boolean} - _buffering\r\n     * @type {boolean}\r\n     * @private\r\n     */\n\n    /**\r\n     * The load promise\r\n     * @member {Promise<Object>} - _loadPromise\r\n     * @type {Promise<Object>}\r\n     * @private\r\n     */\n\n    /**\r\n     * The DRM protocol for the current playback.\r\n     * @type {?Function}\r\n     * @private\r\n     * @static\r\n     */\n\n    /**\r\n     * The supported mime type by the dash adapter\r\n     * @member {string} _dashMimeType\r\n     * @static\r\n     * @private\r\n     */\n\n    /**\r\n     * The id of Adapter\r\n     * @member {string} id\r\n     * @static\r\n     * @public\r\n     */\n    value: function createAdapter(videoElement, source, config) {\n      var dashConfig = {};\n      if (_pakhshkitJs.Utils.Object.hasPropertyPath(config, 'playback.options.html5.dash')) {\n        dashConfig = config.playback.options.html5.dash;\n      }\n      return new this(videoElement, source, dashConfig);\n    }\n\n    /**\r\n     * Checks if dash adapter can play a given mime type\r\n     * @function canPlayType\r\n     * @param {string} mimeType - The mime type to check\r\n     * @returns {boolean} - Whether the dash adapter can play a specific mime type\r\n     * @static\r\n     */\n\n\n    /**\r\n     * 3016 is the number of the video error at shaka, we already listens to it in the html5 class\r\n     * @member {number} - VIDEO_ERROR_CODE\r\n     * @type {number}\r\n     * @private\r\n     */\n\n    /**\r\n     * Whether 'waiting' event has been sent by the HTMLVideoElement\r\n     * @member {boolean} - _waitingSent\r\n     * @type {boolean}\r\n     * @private\r\n     */\n\n    /**\r\n     * an object containing all the events we bind and unbind to.\r\n     * @member {Object} - _adapterEventsBindings\r\n     * @type {Object}\r\n     * @private\r\n     */\n\n    /**\r\n     * The shaka player instance\r\n     * @member {any} _shaka\r\n     * @private\r\n     */\n\n    /**\r\n     * The DRM protocols implementations for dash adapter.\r\n     * @type {Array<Function>}\r\n     * @private\r\n     * @static\r\n     */\n\n    /**\r\n     * The adapter logger\r\n     * @member {any} _logger\r\n     * @private\r\n     * @static\r\n     */\n\n  }, {\n    key: 'canPlayType',\n    value: function canPlayType(mimeType) {\n      var canPlayType = typeof mimeType === 'string' ? mimeType.toLowerCase() === DashAdapter._dashMimeType : false;\n      DashAdapter._logger.debug('canPlayType result for mimeType: ' + mimeType + ' is ' + canPlayType.toString());\n      return canPlayType;\n    }\n\n    /**\r\n     * Checks if dash adapter can play a given drm data.\r\n     * @param {Array<Object>} drmData - The drm data to check.\r\n     * @returns {boolean} - Whether the dash adapter can play a specific drm data.\r\n     * @static\r\n     */\n\n  }, {\n    key: 'canPlayDrm',\n    value: function canPlayDrm(drmData) {\n      var canPlayDrm = false;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = DashAdapter._drmProtocols[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var drmProtocol = _step.value;\n\n          if (drmProtocol.canPlayDrm(drmData)) {\n            DashAdapter._drmProtocol = drmProtocol;\n            canPlayDrm = true;\n            break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      DashAdapter._logger.debug('canPlayDrm result is ' + canPlayDrm.toString(), drmData);\n      return canPlayDrm;\n    }\n\n    /**\r\n     * Checks if the dash adapter is supported\r\n     * @function isSupported\r\n     * @returns {boolean} -  Whether dash is supported.\r\n     * @static\r\n     */\n\n  }, {\n    key: 'isSupported',\n    value: function isSupported() {\n      /*\r\n      for browsers which don't have VTT cue we need to install a polyfill for both isBrowserSupported\r\n      check and also for playback, but we might not use Shaka so if we install the polyfill now just for browser support\r\n      check then uninstall it after, and call it again if we actually use DASH adapter for playback on init\r\n      this is in order to avoid collisions with other libs\r\n       */\n      var resetVttPolyfill = false;\n      if (!window.VTTCue) {\n        resetVttPolyfill = true;\n      }\n      _shakaPlayer2.default.polyfill.installAll();\n      var isSupported = _shakaPlayer2.default.Player.isBrowserSupported();\n      if (resetVttPolyfill) {\n        window.VTTCue = undefined;\n      }\n      DashAdapter._logger.debug('isSupported:' + isSupported);\n      return isSupported;\n    }\n\n    /**\r\n     * @constructor\r\n     * @param {HTMLVideoElement} videoElement - The video element which bind to the dash adapter\r\n     * @param {PKMediaSourceObject} source - The source object\r\n     * @param {Object} config - The media source adapter configuration\r\n     */\n\n  }]);\n\n  function DashAdapter(videoElement, source) {\n    var _this$_adapterEventsB;\n\n    var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, DashAdapter);\n\n    DashAdapter._logger.debug('Creating adapter. Shaka version: ' + _shakaPlayer2.default.Player.version);\n\n    var _this = _possibleConstructorReturn(this, (DashAdapter.__proto__ || Object.getPrototypeOf(DashAdapter)).call(this, videoElement, source, config));\n\n    _this._adapterEventsBindings = (_this$_adapterEventsB = {}, _defineProperty(_this$_adapterEventsB, ShakaEvent.ERROR, function (event) {\n      return _this._onError(event);\n    }), _defineProperty(_this$_adapterEventsB, ShakaEvent.ADAPTATION, function () {\n      return _this._onAdaptation();\n    }), _defineProperty(_this$_adapterEventsB, ShakaEvent.BUFFERING, function (event) {\n      return _this._onBuffering(event);\n    }), _defineProperty(_this$_adapterEventsB, _pakhshkitJs.EventType.WAITING, function () {\n      return _this._onWaiting();\n    }), _defineProperty(_this$_adapterEventsB, _pakhshkitJs.EventType.PLAYING, function () {\n      return _this._onPlaying();\n    }), _this$_adapterEventsB);\n    _this._buffering = false;\n    _this._waitingSent = false;\n    _this._playingSent = false;\n    _this.VIDEO_ERROR_CODE = 3016;\n\n    _this._setShakaConfig();\n    return _this;\n  }\n\n  /**\r\n   * Sets the shaka config.\r\n   * @private\r\n   * @returns {void}\r\n   */\n\n\n  _createClass(DashAdapter, [{\n    key: '_setShakaConfig',\n    value: function _setShakaConfig() {\n      var textDisplayerConfig = {\n        textDisplayFactory: function (videoEl) {\n          return new _textDisplayer2.default(videoEl);\n        }.bind(null, this._videoElement)\n      };\n      this._config = _pakhshkitJs.Utils.Object.mergeDeep(textDisplayerConfig, this._config, _defaultConfig2.default);\n    }\n\n    /**\r\n     * Runs the initialization actions of the dash adapter.\r\n     * @private\r\n     * @returns {void}\r\n     */\n\n  }, {\n    key: '_init',\n    value: function _init() {\n      //Need to call this again cause we are uninstalling the VTTCue polyfill to avoid collisions with other libs\n      _shakaPlayer2.default.polyfill.installAll();\n      this._shaka = new _shakaPlayer2.default.Player(this._videoElement);\n      this._maybeSetDrmConfig();\n      this._shaka.configure(this._config);\n      this._shaka.setTextTrackVisibility(false);\n      this._addBindings();\n    }\n\n    /**\r\n     * Configure drm for shaka player.\r\n     * @private\r\n     * @returns {void}\r\n     */\n\n  }, {\n    key: '_maybeSetDrmConfig',\n    value: function _maybeSetDrmConfig() {\n      if (DashAdapter._drmProtocol && this._sourceObj && this._sourceObj.drmData) {\n        DashAdapter._drmProtocol.setDrmPlayback(this._config, this._sourceObj.drmData);\n      }\n    }\n\n    /**\r\n     * Add the required bindings to shaka.\r\n     * @function _addBindings\r\n     * @private\r\n     * @returns {void}\r\n     */\n\n  }, {\n    key: '_addBindings',\n    value: function _addBindings() {\n      this._shaka.addEventListener(ShakaEvent.ADAPTATION, this._adapterEventsBindings.adaptation);\n      this._shaka.addEventListener(ShakaEvent.ERROR, this._adapterEventsBindings.error);\n      this._shaka.addEventListener(ShakaEvent.BUFFERING, this._adapterEventsBindings.buffering);\n      this._videoElement.addEventListener(_pakhshkitJs.EventType.WAITING, this._adapterEventsBindings.waiting);\n      this._videoElement.addEventListener(_pakhshkitJs.EventType.PLAYING, this._adapterEventsBindings.playing);\n    }\n\n    /**\r\n     * Remove the bindings to shaka.\r\n     * @function _removeBindings\r\n     * @private\r\n     * @returns {void}\r\n     */\n\n  }, {\n    key: '_removeBindings',\n    value: function _removeBindings() {\n      this._shaka.removeEventListener(ShakaEvent.ADAPTATION, this._adapterEventsBindings.adaptation);\n      this._shaka.removeEventListener(ShakaEvent.ERROR, this._adapterEventsBindings.error);\n      this._shaka.removeEventListener(ShakaEvent.BUFFERING, this._adapterEventsBindings.buffering);\n      this._videoElement.removeEventListener(_pakhshkitJs.EventType.WAITING, this._adapterEventsBindings.waiting);\n      this._videoElement.removeEventListener(_pakhshkitJs.EventType.PLAYING, this._adapterEventsBindings.playing);\n    }\n\n    /**\r\n     * Load the video source\r\n     * @param {number} startTime - Optional time to start the video from.\r\n     * @function load\r\n     * @override\r\n     */\n\n  }, {\n    key: 'load',\n    value: function load(startTime) {\n      var _this2 = this;\n\n      if (!this._loadPromise) {\n        this._init();\n        this._loadPromise = new Promise(function (resolve, reject) {\n          if (_this2._sourceObj && _this2._sourceObj.url) {\n            _this2._trigger(_pakhshkitJs.EventType.ABR_MODE_CHANGED, { mode: _this2.isAdaptiveBitrateEnabled() ? 'auto' : 'manual' });\n            var shakaStartTime = startTime && startTime > -1 ? startTime : undefined;\n            _this2._shaka.load(_this2._sourceObj.url, shakaStartTime).then(function () {\n              var data = { tracks: _this2._getParsedTracks() };\n              DashAdapter._logger.debug('The source has been loaded successfully');\n              resolve(data);\n            }).catch(function (error) {\n              reject(new _pakhshkitJs.Error(error.severity, error.category, error.code, error.data));\n            });\n          }\n        });\n      }\n      return this._loadPromise;\n    }\n\n    /**\r\n     * Destroys the dash adapter\r\n     * @function destroy\r\n     * @override\r\n     * @returns {Promise<*>} - The destroy promise.\r\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      var _this3 = this;\n\n      return _get(DashAdapter.prototype.__proto__ || Object.getPrototypeOf(DashAdapter.prototype), 'destroy', this).call(this).then(function () {\n        DashAdapter._logger.debug('destroy');\n        _this3._loadPromise = null;\n        _this3._buffering = false;\n        _this3._waitingSent = false;\n        _this3._playingSent = false;\n        if (_this3._shaka) {\n          _this3._removeBindings();\n          return _this3._shaka.destroy();\n        }\n        _this3._adapterEventsBindings = {};\n      });\n    }\n\n    /**\r\n     * Get the original video tracks\r\n     * @function _getVideoTracks\r\n     * @returns {Array<Object>} - The original video tracks\r\n     * @private\r\n     */\n\n  }, {\n    key: '_getVideoTracks',\n    value: function _getVideoTracks() {\n      var variantTracks = this._shaka.getVariantTracks();\n      var activeVariantTrack = variantTracks.filter(function (variantTrack) {\n        return variantTrack.active;\n      })[0];\n      var videoTracks = variantTracks.filter(function (variantTrack) {\n        return variantTrack.audioId === activeVariantTrack.audioId;\n      });\n      return videoTracks;\n    }\n\n    /**\r\n     * Get the original audio tracks\r\n     * @function _getAudioTracks\r\n     * @returns {Array<Object>} - The original audio tracks\r\n     * @private\r\n     */\n\n  }, {\n    key: '_getAudioTracks',\n    value: function _getAudioTracks() {\n      var variantTracks = this._shaka.getVariantTracks();\n      var activeVariantTrack = variantTracks.filter(function (variantTrack) {\n        return variantTrack.active;\n      })[0];\n      var audioTracks = variantTracks.filter(function (variantTrack) {\n        return variantTrack.videoId === activeVariantTrack.videoId;\n      });\n      return audioTracks;\n    }\n\n    /**\r\n     * Get the parsed tracks\r\n     * @function _getParsedTracks\r\n     * @returns {Array<Track>} - The parsed tracks\r\n     * @private\r\n     */\n\n  }, {\n    key: '_getParsedTracks',\n    value: function _getParsedTracks() {\n      if (this._shaka) {\n        var videoTracks = this._getParsedVideoTracks();\n        var audioTracks = this._getParsedAudioTracks();\n        var textTracks = this._getParsedTextTracks();\n        return videoTracks.concat(audioTracks).concat(textTracks);\n      }\n      return [];\n    }\n\n    /**\r\n     * Get the parsed video tracks\r\n     * @function _getParsedVideoTracks\r\n     * @returns {Array<VideoTrack>} - The parsed video tracks\r\n     * @private\r\n     */\n\n  }, {\n    key: '_getParsedVideoTracks',\n    value: function _getParsedVideoTracks() {\n      var videoTracks = this._getVideoTracks();\n      var parsedTracks = [];\n      if (videoTracks) {\n        for (var i = 0; i < videoTracks.length; i++) {\n          var settings = {\n            id: videoTracks[i].id,\n            bandwidth: videoTracks[i].bandwidth,\n            width: videoTracks[i].width,\n            height: videoTracks[i].height,\n            active: videoTracks[i].active,\n            index: i\n          };\n          parsedTracks.push(new _pakhshkitJs.VideoTrack(settings));\n        }\n      }\n      return parsedTracks;\n    }\n\n    /**\r\n     * Get the parsed audio tracks\r\n     * @function _getParsedAudioTracks\r\n     * @returns {Array<AudioTrack>} - The parsed audio tracks\r\n     * @private\r\n     */\n\n  }, {\n    key: '_getParsedAudioTracks',\n    value: function _getParsedAudioTracks() {\n      var audioTracks = this._getAudioTracks();\n      var parsedTracks = [];\n      if (audioTracks) {\n        for (var i = 0; i < audioTracks.length; i++) {\n          var settings = {\n            id: audioTracks[i].id,\n            active: audioTracks[i].active,\n            label: audioTracks[i].label,\n            language: audioTracks[i].language,\n            index: i\n          };\n          parsedTracks.push(new _pakhshkitJs.AudioTrack(settings));\n        }\n      }\n      return parsedTracks;\n    }\n\n    /**\r\n     * Get the parsed text tracks\r\n     * @function _getParsedTextTracks\r\n     * @returns {Array<TextTrack>} - The parsed text tracks\r\n     * @private\r\n     */\n\n  }, {\n    key: '_getParsedTextTracks',\n    value: function _getParsedTextTracks() {\n      var textTracks = this._shaka.getTextTracks();\n      var parsedTracks = [];\n      if (textTracks) {\n        for (var i = 0; i < textTracks.length; i++) {\n          var settings = {\n            kind: textTracks[i].kind ? textTracks[i].kind + 's' : \"\",\n            active: false,\n            label: textTracks[i].label,\n            language: textTracks[i].language,\n            index: i\n          };\n          parsedTracks.push(new _pakhshkitJs.TextTrack(settings));\n        }\n      }\n      return parsedTracks;\n    }\n\n    /**\r\n     * Select a video track\r\n     * @function selectVideoTrack\r\n     * @param {VideoTrack} videoTrack - the video track to select\r\n     * @returns {void}\r\n     * @public\r\n     */\n\n  }, {\n    key: 'selectVideoTrack',\n    value: function selectVideoTrack(videoTrack) {\n      if (this._shaka) {\n        var videoTracks = this._getVideoTracks();\n        if (videoTrack instanceof _pakhshkitJs.VideoTrack && videoTracks) {\n          var selectedVideoTrack = videoTracks[videoTrack.index];\n          if (selectedVideoTrack) {\n            if (this.isAdaptiveBitrateEnabled()) {\n              this._shaka.configure({ abr: { enabled: false } });\n              this._trigger(_pakhshkitJs.EventType.ABR_MODE_CHANGED, { mode: 'manual' });\n            }\n            if (!selectedVideoTrack.active) {\n              this._shaka.selectVariantTrack(videoTracks[videoTrack.index], true);\n              this._onTrackChanged(videoTrack);\n            }\n          }\n        }\n      }\n    }\n\n    /**\r\n     * Select an audio track\r\n     * @function selectAudioTrack\r\n     * @param {AudioTrack} audioTrack - the audio track to select\r\n     * @returns {void}\r\n     * @public\r\n     */\n\n  }, {\n    key: 'selectAudioTrack',\n    value: function selectAudioTrack(audioTrack) {\n      if (this._shaka && audioTrack instanceof _pakhshkitJs.AudioTrack && !audioTrack.active) {\n        this._shaka.selectAudioLanguage(audioTrack.language);\n        this._onTrackChanged(audioTrack);\n      }\n    }\n\n    /**\r\n     * Select a text track\r\n     * @function selectTextTrack\r\n     * @param {TextTrack} textTrack - the track to select\r\n     * @returns {void}\r\n     * @public\r\n     */\n\n  }, {\n    key: 'selectTextTrack',\n    value: function selectTextTrack(textTrack) {\n      if (this._shaka && textTrack instanceof _pakhshkitJs.TextTrack && !textTrack.active && (textTrack.kind === 'subtitles' || textTrack.kind === 'captions')) {\n        this._shaka.selectTextLanguage(textTrack.language);\n        this._onTrackChanged(textTrack);\n      }\n    }\n\n    /**\r\n     * Hide the text track\r\n     * @function hideTextTrack\r\n     * @returns {void}\r\n     * @public\r\n     */\n\n  }, {\n    key: 'hideTextTrack',\n    value: function hideTextTrack() {\n      if (this._shaka) {\n        this._shaka.setTextTrackVisibility(false);\n      }\n    }\n\n    /**\r\n     * Enables adaptive bitrate switching\r\n     * @function enableAdaptiveBitrate\r\n     * @returns {void}\r\n     * @public\r\n     */\n\n  }, {\n    key: 'enableAdaptiveBitrate',\n    value: function enableAdaptiveBitrate() {\n      if (this._shaka && !this.isAdaptiveBitrateEnabled()) {\n        this._trigger(_pakhshkitJs.EventType.ABR_MODE_CHANGED, { mode: 'auto' });\n        this._shaka.configure({ abr: { enabled: true } });\n      }\n    }\n\n    /**\r\n     * Checking if adaptive bitrate switching is enabled.\r\n     * @function isAdaptiveBitrateEnabled\r\n     * @returns {boolean} - Whether adaptive bitrate is enabled.\r\n     * @public\r\n     */\n\n  }, {\n    key: 'isAdaptiveBitrateEnabled',\n    value: function isAdaptiveBitrateEnabled() {\n      if (this._shaka) {\n        var shakaConfig = this._shaka.getConfiguration();\n        return shakaConfig.abr.enabled;\n      }\n      return false;\n    }\n\n    /**\r\n     * Returns the live edge\r\n     * @returns {number} - live edge\r\n     * @private\r\n     */\n\n  }, {\n    key: '_getLiveEdge',\n    value: function _getLiveEdge() {\n      return this._shaka ? this._shaka.seekRange().end : NaN;\n    }\n\n    /**\r\n     * Seeking to live edge.\r\n     * @function seekToLiveEdge\r\n     * @returns {void}\r\n     * @public\r\n     */\n\n  }, {\n    key: 'seekToLiveEdge',\n    value: function seekToLiveEdge() {\n      if (this._shaka) {\n        this._videoElement.currentTime = this._shaka.seekRange().end;\n      }\n    }\n\n    /**\r\n     * Checking if the current playback is live.\r\n     * @function isLive\r\n     * @returns {boolean} - Whether playback is live.\r\n     * @public\r\n     */\n\n  }, {\n    key: 'isLive',\n    value: function isLive() {\n      if (this._shaka) {\n        return this._shaka.isLive();\n      }\n      return false;\n    }\n\n    /**\r\n     * An handler to shaka adaptation event\r\n     * @function _onAdaptation\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n  }, {\n    key: '_onAdaptation',\n    value: function _onAdaptation() {\n      var selectedVideoTrack = this._getParsedVideoTracks().filter(function (videoTrack) {\n        return videoTrack.active;\n      })[0];\n      this._onTrackChanged(selectedVideoTrack);\n    }\n\n    /**\r\n     * An handler to shaka error event\r\n     * @function _onError\r\n     * @param {any} event - the error event\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n  }, {\n    key: '_onError',\n    value: function _onError(event) {\n      if (event && event.detail) {\n        var error = event.detail;\n        //don't handle video element errors, they are already handled by the player\n        if (error.code === this.VIDEO_ERROR_CODE) {\n          return;\n        }\n        this._trigger(_pakhshkitJs.EventType.ERROR, new _pakhshkitJs.Error(error.severity, error.category, error.code, error.data));\n        DashAdapter._logger.error(error);\n      }\n    }\n\n    /**\r\n     * An handler to shaka buffering event\r\n     * @function _onBuffering\r\n     * @param {any} event - the buffering event\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n  }, {\n    key: '_onBuffering',\n    value: function _onBuffering(event) {\n      if (event.buffering) {\n        if (!this._waitingSent) {\n          // The player enters the buffering state and 'waiting' event hasn't been sent by the HTMLVideoElement.\n          this._videoElement.dispatchEvent(new window.Event(_pakhshkitJs.EventType.WAITING));\n          this._buffering = true;\n        }\n      } else {\n        this._buffering = false;\n        if (!this._videoElement.paused && !this._playingSent) {\n          //the player leaves the buffering state. and 'playing' event hasn't been sent by the HTMLVideoElement.\n          this._videoElement.dispatchEvent(new window.Event(_pakhshkitJs.EventType.PLAYING));\n        }\n      }\n    }\n\n    /**\r\n     * An handler to HTMLVideoElement waiting event\r\n     * @function _onWaiting\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n  }, {\n    key: '_onWaiting',\n    value: function _onWaiting() {\n      this._waitingSent = true;\n      this._playingSent = false;\n    }\n\n    /**\r\n     * An handler to HTMLVideoElement playing event\r\n     * @function _onPlaying\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n  }, {\n    key: '_onPlaying',\n    value: function _onPlaying() {\n      this._playingSent = true;\n      this._waitingSent = false;\n      if (this._buffering) {\n        // The player is in buffering state.\n        this._videoElement.dispatchEvent(new window.Event(_pakhshkitJs.EventType.WAITING));\n      }\n    }\n\n    /**\r\n     * Get the start time of DVR window in live playback in seconds.\r\n     * @returns {Number} - start time of DVR window.\r\n     * @public\r\n     */\n\n  }, {\n    key: 'getStartTimeOfDvrWindow',\n    value: function getStartTimeOfDvrWindow() {\n      if (this.isLive() && this._shaka) {\n        return this._shaka.seekRange().start;\n      } else {\n        return 0;\n      }\n    }\n  }]);\n\n  return DashAdapter;\n}(_pakhshkitJs.BaseMediaSourceAdapter);\n\nDashAdapter.id = 'DashAdapter';\nDashAdapter._logger = _pakhshkitJs.BaseMediaSourceAdapter.getLogger(DashAdapter.id);\nDashAdapter._dashMimeType = 'application/dash+xml';\nDashAdapter._drmProtocols = [_widevine2.default, _playready2.default];\nDashAdapter._drmProtocol = null;\nexports.default = DashAdapter;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _pakhshkitJs = __webpack_require__(0);\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar DrmSupport = _pakhshkitJs.BaseDrmProtocol.DrmSupport;\nvar DrmScheme = _pakhshkitJs.BaseDrmProtocol.DrmScheme;\n\nvar Widevine = function (_BaseDrmProtocol) {\n  _inherits(Widevine, _BaseDrmProtocol);\n\n  function Widevine() {\n    _classCallCheck(this, Widevine);\n\n    return _possibleConstructorReturn(this, (Widevine.__proto__ || Object.getPrototypeOf(Widevine)).apply(this, arguments));\n  }\n\n  _createClass(Widevine, null, [{\n    key: 'canPlayDrm',\n\n\n    /**\r\n     * Widevine playback supports in case 2 conditions are met:\r\n     * 1. The environment supports Widevine playback.\r\n     * 2. The drm data of the source object contains entry with Widevine scheme.\r\n     * @param {Array<Object>} drmData - The drm data to check.\r\n     * @return {boolean} - Whether FairPlay can be play on the current environment.\r\n     */\n    value: function canPlayDrm(drmData) {\n      Widevine._logger.debug(\"Can play DRM scheme of: \" + DrmScheme.WIDEVINE);\n      return DrmSupport.isProtocolSupported(DrmScheme.WIDEVINE, drmData);\n    }\n\n    /**\r\n     * Sets the Widevine playback.\r\n     * @param {Object} config - The shaka player config.\r\n     * @param {Array<Object>} drmData - The drm data.\r\n     * @returns {void}\r\n     */\n\n  }, {\n    key: 'setDrmPlayback',\n    value: function setDrmPlayback(config, drmData) {\n      Widevine._logger.debug(\"Sets drm playback\");\n      var browser = _pakhshkitJs.Env.browser.name;\n      var wwDrmEntry = drmData.find(function (drmEntry) {\n        return drmEntry.scheme === DrmScheme.WIDEVINE;\n      });\n      if (wwDrmEntry) {\n        config.drm = {\n          servers: _defineProperty({}, DrmScheme.WIDEVINE, wwDrmEntry.licenseUrl),\n          advanced: {}\n        };\n        if (browser === 'Chrome') {\n          config.drm.advanced = _defineProperty({}, DrmScheme.WIDEVINE, {\n            'videoRobustness': 'SW_SECURE_CRYPTO',\n            'audioRobustness': 'SW_SECURE_CRYPTO'\n          });\n        }\n      }\n    }\n  }]);\n\n  return Widevine;\n}(_pakhshkitJs.BaseDrmProtocol);\n\nWidevine._logger = _pakhshkitJs.BaseDrmProtocol.getLogger('Widevine');\nexports.default = Widevine;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _pakhshkitJs = __webpack_require__(0);\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar DrmSupport = _pakhshkitJs.BaseDrmProtocol.DrmSupport;\nvar DrmScheme = _pakhshkitJs.BaseDrmProtocol.DrmScheme;\n\nvar PlayReady = function (_BaseDrmProtocol) {\n  _inherits(PlayReady, _BaseDrmProtocol);\n\n  function PlayReady() {\n    _classCallCheck(this, PlayReady);\n\n    return _possibleConstructorReturn(this, (PlayReady.__proto__ || Object.getPrototypeOf(PlayReady)).apply(this, arguments));\n  }\n\n  _createClass(PlayReady, null, [{\n    key: 'canPlayDrm',\n\n\n    /**\r\n     * PlayReady playback supports in case 2 conditions are met:\r\n     * 1. The environment supports PlayReady playback.\r\n     * 2. The drm data of the source object contains entry with PlayReady scheme.\r\n     * @param {Array<Object>} drmData - The drm data to check.\r\n     * @return {boolean} - Whether FairPlay can be play on the current environment.\r\n     */\n    value: function canPlayDrm(drmData) {\n      PlayReady._logger.debug(\"Can play DRM scheme of: \" + DrmScheme.PLAYREADY);\n      return DrmSupport.isProtocolSupported(DrmScheme.PLAYREADY, drmData);\n    }\n\n    /**\r\n     * Sets the PlayReady playback.\r\n     * @param {Object} config - The shaka player config.\r\n     * @param {Array<Object>} drmData - The drm data.\r\n     * @returns {void}\r\n     */\n\n  }, {\n    key: 'setDrmPlayback',\n    value: function setDrmPlayback(config, drmData) {\n      PlayReady._logger.debug(\"Sets drm playback\");\n      var prDrmEntry = drmData.find(function (drmEntry) {\n        return drmEntry.scheme === DrmScheme.PLAYREADY;\n      });\n      if (prDrmEntry) {\n        config.drm = {\n          servers: _defineProperty({}, DrmScheme.PLAYREADY, prDrmEntry.licenseUrl)\n        };\n      }\n    }\n  }]);\n\n  return PlayReady;\n}(_pakhshkitJs.BaseDrmProtocol);\n\nPlayReady._logger = _pakhshkitJs.BaseDrmProtocol.getLogger('PlayReady');\nexports.default = PlayReady;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nmodule.exports = {\"streaming\":{\"ignoreTextStreamFailures\":true}}\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _shakaPlayer = __webpack_require__(1);\n\nvar _shakaPlayer2 = _interopRequireDefault(_shakaPlayer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * shaka doesn't handle hidden caption see https://github.com/google/shaka-player/issues/1058.\r\n * This stops us to handle the caption by ourself by setting the native caption hidden.\r\n * So we have to override the shaka text displayer to cause shaka handles hidden caption.\r\n */\nvar TextDisplayer = function (_shaka$text$SimpleTex) {\n  _inherits(TextDisplayer, _shaka$text$SimpleTex);\n\n  function TextDisplayer() {\n    _classCallCheck(this, TextDisplayer);\n\n    return _possibleConstructorReturn(this, (TextDisplayer.__proto__ || Object.getPrototypeOf(TextDisplayer)).apply(this, arguments));\n  }\n\n  _createClass(TextDisplayer, [{\n    key: 'isTextVisible',\n\n    /**\r\n     *\r\n     * @return {boolean} - isTextVisible\r\n     */\n    value: function isTextVisible() {\n      return true;\n    }\n  }]);\n\n  return TextDisplayer;\n}(_shakaPlayer2.default.text.SimpleTextDisplayer);\n\nexports.default = TextDisplayer;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// pakhshkit-dash.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ce63100370231764307a","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"pakhshkit-js\",\"commonjs2\":\"pakhshkit-js\",\"amd\":\"pakhshkit-js\",\"root\":[\"pakhshkit\",\"core\"]}\n// module id = 0\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"commonjs\":\"shaka-player\",\"commonjs2\":\"shaka-player\",\"amd\":\"shaka-player\",\"root\":\"shaka\"}\n// module id = 1\n// module chunks = 0","// @flow\r\nimport {registerMediaSourceAdapter} from 'pakhshkit-js'\r\nimport DashAdapter from './dash-adapter'\r\n\r\ndeclare var __VERSION__: string;\r\ndeclare var __NAME__: string;\r\n\r\nexport default DashAdapter;\r\nexport {__VERSION__ as VERSION, __NAME__ as NAME};\r\n\r\n// Register DashAdapter to the media source adapter manager\r\nif (DashAdapter.isSupported()) {\r\n  registerMediaSourceAdapter(DashAdapter);\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","// @flow\r\nimport shaka from 'shaka-player';\r\nimport {AudioTrack, BaseMediaSourceAdapter, Error, EventType, TextTrack, Track, Utils, VideoTrack} from 'pakhshkit-js'\r\nimport Widevine from './drm/widevine'\r\nimport PlayReady from './drm/playready'\r\nimport DefaultConfig from './default-config'\r\nimport TextDisplayer from './text-displayer'\r\n\r\ntype ShakaEventType = { [event: string]: string };\r\n\r\n/**\r\n * Shaka events enum\r\n * @type {Object}\r\n * @const\r\n */\r\nconst ShakaEvent: ShakaEventType = {\r\n  ERROR: 'error',\r\n  ADAPTATION: 'adaptation',\r\n  BUFFERING: 'buffering'\r\n};\r\n\r\n/**\r\n * Adapter of shaka lib for dash content\r\n * @classdesc\r\n */\r\nexport default class DashAdapter extends BaseMediaSourceAdapter {\r\n  /**\r\n   * The id of Adapter\r\n   * @member {string} id\r\n   * @static\r\n   * @public\r\n   */\r\n  static id = 'DashAdapter';\r\n  /**\r\n   * The adapter logger\r\n   * @member {any} _logger\r\n   * @private\r\n   * @static\r\n   */\r\n  static _logger = BaseMediaSourceAdapter.getLogger(DashAdapter.id);\r\n  /**\r\n   * The supported mime type by the dash adapter\r\n   * @member {string} _dashMimeType\r\n   * @static\r\n   * @private\r\n   */\r\n  static _dashMimeType = 'application/dash+xml';\r\n  /**\r\n   * The DRM protocols implementations for dash adapter.\r\n   * @type {Array<Function>}\r\n   * @private\r\n   * @static\r\n   */\r\n  static _drmProtocols: Array<Function> = [Widevine, PlayReady];\r\n  /**\r\n   * The DRM protocol for the current playback.\r\n   * @type {?Function}\r\n   * @private\r\n   * @static\r\n   */\r\n  static _drmProtocol: ?Function = null;\r\n  /**\r\n   * The shaka player instance\r\n   * @member {any} _shaka\r\n   * @private\r\n   */\r\n  _shaka: any;\r\n  /**\r\n   * an object containing all the events we bind and unbind to.\r\n   * @member {Object} - _adapterEventsBindings\r\n   * @type {Object}\r\n   * @private\r\n   */\r\n  _adapterEventsBindings: { [name: string]: Function } = {\r\n    [ShakaEvent.ERROR]: (event) => this._onError(event),\r\n    [ShakaEvent.ADAPTATION]: () => this._onAdaptation(),\r\n    [ShakaEvent.BUFFERING]: (event) => this._onBuffering(event),\r\n    [EventType.WAITING]: () => this._onWaiting(),\r\n    [EventType.PLAYING]: () => this._onPlaying()\r\n  };\r\n  /**\r\n   * The load promise\r\n   * @member {Promise<Object>} - _loadPromise\r\n   * @type {Promise<Object>}\r\n   * @private\r\n   */\r\n  _loadPromise: ?Promise<Object>;\r\n  /**\r\n   * The buffering state flag\r\n   * @member {boolean} - _buffering\r\n   * @type {boolean}\r\n   * @private\r\n   */\r\n  _buffering: boolean = false;\r\n  /**\r\n   * Whether 'waiting' event has been sent by the HTMLVideoElement\r\n   * @member {boolean} - _waitingSent\r\n   * @type {boolean}\r\n   * @private\r\n   */\r\n  _waitingSent: boolean = false;\r\n  /**\r\n   * Whether 'playing' event has been sent by the HTMLVideoElement\r\n   * @member {boolean} - _playingSent\r\n   * @type {boolean}\r\n   * @private\r\n   */\r\n  _playingSent: boolean = false;\r\n\r\n  /**\r\n   * 3016 is the number of the video error at shaka, we already listens to it in the html5 class\r\n   * @member {number} - VIDEO_ERROR_CODE\r\n   * @type {number}\r\n   * @private\r\n   */\r\n  VIDEO_ERROR_CODE: number = 3016;\r\n\r\n  /**\r\n   * Factory method to create media source adapter.\r\n   * @function createAdapter\r\n   * @param {HTMLVideoElement} videoElement - The video element that the media source adapter work with.\r\n   * @param {PKMediaSourceObject} source - The source Object.\r\n   * @param {Object} config - The player configuration.\r\n   * @returns {IMediaSourceAdapter} - New instance of the run time media source adapter.\r\n   * @static\r\n   */\r\n  static createAdapter(videoElement: HTMLVideoElement, source: PKMediaSourceObject, config: Object): IMediaSourceAdapter {\r\n    let dashConfig = {};\r\n    if (Utils.Object.hasPropertyPath(config, 'playback.options.html5.dash')) {\r\n      dashConfig = config.playback.options.html5.dash;\r\n    }\r\n    return new this(videoElement, source, dashConfig);\r\n  }\r\n\r\n  /**\r\n   * Checks if dash adapter can play a given mime type\r\n   * @function canPlayType\r\n   * @param {string} mimeType - The mime type to check\r\n   * @returns {boolean} - Whether the dash adapter can play a specific mime type\r\n   * @static\r\n   */\r\n  static canPlayType(mimeType: string): boolean {\r\n    let canPlayType = typeof mimeType === 'string' ? mimeType.toLowerCase() === DashAdapter._dashMimeType : false;\r\n    DashAdapter._logger.debug('canPlayType result for mimeType: ' + mimeType + ' is ' + canPlayType.toString());\r\n    return canPlayType;\r\n  }\r\n\r\n  /**\r\n   * Checks if dash adapter can play a given drm data.\r\n   * @param {Array<Object>} drmData - The drm data to check.\r\n   * @returns {boolean} - Whether the dash adapter can play a specific drm data.\r\n   * @static\r\n   */\r\n  static canPlayDrm(drmData: Array<Object>): boolean {\r\n    let canPlayDrm = false;\r\n    for (let drmProtocol of DashAdapter._drmProtocols) {\r\n      if (drmProtocol.canPlayDrm(drmData)) {\r\n        DashAdapter._drmProtocol = drmProtocol;\r\n        canPlayDrm = true;\r\n        break;\r\n      }\r\n    }\r\n    DashAdapter._logger.debug('canPlayDrm result is ' + canPlayDrm.toString(), drmData);\r\n    return canPlayDrm;\r\n  }\r\n\r\n  /**\r\n   * Checks if the dash adapter is supported\r\n   * @function isSupported\r\n   * @returns {boolean} -  Whether dash is supported.\r\n   * @static\r\n   */\r\n  static isSupported(): boolean {\r\n    /*\r\n    for browsers which don't have VTT cue we need to install a polyfill for both isBrowserSupported\r\n    check and also for playback, but we might not use Shaka so if we install the polyfill now just for browser support\r\n    check then uninstall it after, and call it again if we actually use DASH adapter for playback on init\r\n    this is in order to avoid collisions with other libs\r\n     */\r\n    let resetVttPolyfill = false;\r\n    if (!window.VTTCue) {\r\n      resetVttPolyfill = true;\r\n    }\r\n    shaka.polyfill.installAll();\r\n    let isSupported = shaka.Player.isBrowserSupported();\r\n    if (resetVttPolyfill) {\r\n      window.VTTCue = undefined;\r\n    }\r\n    DashAdapter._logger.debug('isSupported:' + isSupported);\r\n    return isSupported;\r\n  }\r\n\r\n  /**\r\n   * @constructor\r\n   * @param {HTMLVideoElement} videoElement - The video element which bind to the dash adapter\r\n   * @param {PKMediaSourceObject} source - The source object\r\n   * @param {Object} config - The media source adapter configuration\r\n   */\r\n  constructor(videoElement: HTMLVideoElement, source: PKMediaSourceObject, config: Object = {}) {\r\n    DashAdapter._logger.debug('Creating adapter. Shaka version: ' + shaka.Player.version);\r\n    super(videoElement, source, config);\r\n    this._setShakaConfig();\r\n  }\r\n\r\n  /**\r\n   * Sets the shaka config.\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  _setShakaConfig(): void {\r\n    const textDisplayerConfig = {\r\n      textDisplayFactory: function (videoEl) {\r\n        return new TextDisplayer(videoEl);\r\n      }.bind(null, this._videoElement)\r\n    };\r\n    this._config = Utils.Object.mergeDeep(textDisplayerConfig, this._config, DefaultConfig);\r\n  }\r\n\r\n  /**\r\n   * Runs the initialization actions of the dash adapter.\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  _init(): void {\r\n    //Need to call this again cause we are uninstalling the VTTCue polyfill to avoid collisions with other libs\r\n    shaka.polyfill.installAll();\r\n    this._shaka = new shaka.Player(this._videoElement);\r\n    this._maybeSetDrmConfig();\r\n    this._shaka.configure(this._config);\r\n    this._shaka.setTextTrackVisibility(false);\r\n    this._addBindings();\r\n  }\r\n\r\n  /**\r\n   * Configure drm for shaka player.\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  _maybeSetDrmConfig(): void {\r\n    if (DashAdapter._drmProtocol && this._sourceObj && this._sourceObj.drmData) {\r\n      DashAdapter._drmProtocol.setDrmPlayback(this._config, this._sourceObj.drmData);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add the required bindings to shaka.\r\n   * @function _addBindings\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  _addBindings(): void {\r\n    this._shaka.addEventListener(ShakaEvent.ADAPTATION, this._adapterEventsBindings.adaptation);\r\n    this._shaka.addEventListener(ShakaEvent.ERROR, this._adapterEventsBindings.error);\r\n    this._shaka.addEventListener(ShakaEvent.BUFFERING, this._adapterEventsBindings.buffering);\r\n    this._videoElement.addEventListener(EventType.WAITING, this._adapterEventsBindings.waiting);\r\n    this._videoElement.addEventListener(EventType.PLAYING, this._adapterEventsBindings.playing);\r\n  }\r\n\r\n  /**\r\n   * Remove the bindings to shaka.\r\n   * @function _removeBindings\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  _removeBindings(): void {\r\n    this._shaka.removeEventListener(ShakaEvent.ADAPTATION, this._adapterEventsBindings.adaptation);\r\n    this._shaka.removeEventListener(ShakaEvent.ERROR, this._adapterEventsBindings.error);\r\n    this._shaka.removeEventListener(ShakaEvent.BUFFERING, this._adapterEventsBindings.buffering);\r\n    this._videoElement.removeEventListener(EventType.WAITING, this._adapterEventsBindings.waiting);\r\n    this._videoElement.removeEventListener(EventType.PLAYING, this._adapterEventsBindings.playing);\r\n  }\r\n\r\n  /**\r\n   * Load the video source\r\n   * @param {number} startTime - Optional time to start the video from.\r\n   * @function load\r\n   * @override\r\n   */\r\n  load(startTime: ?number): Promise<Object> {\r\n    if (!this._loadPromise) {\r\n      this._init();\r\n      this._loadPromise = new Promise((resolve, reject) => {\r\n        if (this._sourceObj && this._sourceObj.url) {\r\n          this._trigger(EventType.ABR_MODE_CHANGED, {mode: this.isAdaptiveBitrateEnabled() ? 'auto' : 'manual'});\r\n          const shakaStartTime = (startTime && startTime > -1 ? startTime : undefined);\r\n          this._shaka.load(this._sourceObj.url, shakaStartTime).then(() => {\r\n            let data = {tracks: this._getParsedTracks()};\r\n            DashAdapter._logger.debug('The source has been loaded successfully');\r\n            resolve(data);\r\n          }).catch((error) => {\r\n            reject(new Error(\r\n              error.severity,\r\n              error.category,\r\n              error.code,\r\n              error.data));\r\n          });\r\n        }\r\n      });\r\n    }\r\n    return this._loadPromise;\r\n  }\r\n\r\n  /**\r\n   * Destroys the dash adapter\r\n   * @function destroy\r\n   * @override\r\n   * @returns {Promise<*>} - The destroy promise.\r\n   */\r\n  destroy(): Promise<*> {\r\n    return super.destroy().then(() => {\r\n      DashAdapter._logger.debug('destroy');\r\n      this._loadPromise = null;\r\n      this._buffering = false;\r\n      this._waitingSent = false;\r\n      this._playingSent = false;\r\n      if (this._shaka) {\r\n        this._removeBindings();\r\n        return this._shaka.destroy();\r\n      }\r\n      this._adapterEventsBindings = {};\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get the original video tracks\r\n   * @function _getVideoTracks\r\n   * @returns {Array<Object>} - The original video tracks\r\n   * @private\r\n   */\r\n  _getVideoTracks(): Array<Object> {\r\n    let variantTracks = this._shaka.getVariantTracks();\r\n    let activeVariantTrack = variantTracks.filter((variantTrack) => {\r\n      return variantTrack.active;\r\n    })[0];\r\n    let videoTracks = variantTracks.filter((variantTrack) => {\r\n      return variantTrack.audioId === activeVariantTrack.audioId;\r\n    });\r\n    return videoTracks;\r\n  }\r\n\r\n  /**\r\n   * Get the original audio tracks\r\n   * @function _getAudioTracks\r\n   * @returns {Array<Object>} - The original audio tracks\r\n   * @private\r\n   */\r\n  _getAudioTracks(): Array<Object> {\r\n    let variantTracks = this._shaka.getVariantTracks();\r\n    let activeVariantTrack = variantTracks.filter((variantTrack) => {\r\n      return variantTrack.active;\r\n    })[0];\r\n    let audioTracks = variantTracks.filter((variantTrack) => {\r\n      return variantTrack.videoId === activeVariantTrack.videoId;\r\n    });\r\n    return audioTracks;\r\n  }\r\n\r\n  /**\r\n   * Get the parsed tracks\r\n   * @function _getParsedTracks\r\n   * @returns {Array<Track>} - The parsed tracks\r\n   * @private\r\n   */\r\n  _getParsedTracks(): Array<Track> {\r\n    if (this._shaka) {\r\n      let videoTracks = this._getParsedVideoTracks();\r\n      let audioTracks = this._getParsedAudioTracks();\r\n      let textTracks = this._getParsedTextTracks();\r\n      return videoTracks.concat(audioTracks).concat(textTracks);\r\n    }\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Get the parsed video tracks\r\n   * @function _getParsedVideoTracks\r\n   * @returns {Array<VideoTrack>} - The parsed video tracks\r\n   * @private\r\n   */\r\n  _getParsedVideoTracks(): Array<VideoTrack> {\r\n    let videoTracks = this._getVideoTracks();\r\n    let parsedTracks = [];\r\n    if (videoTracks) {\r\n      for (let i = 0; i < videoTracks.length; i++) {\r\n        let settings = {\r\n          id: videoTracks[i].id,\r\n          bandwidth: videoTracks[i].bandwidth,\r\n          width: videoTracks[i].width,\r\n          height: videoTracks[i].height,\r\n          active: videoTracks[i].active,\r\n          index: i\r\n        };\r\n        parsedTracks.push(new VideoTrack(settings));\r\n      }\r\n    }\r\n    return parsedTracks;\r\n  }\r\n\r\n  /**\r\n   * Get the parsed audio tracks\r\n   * @function _getParsedAudioTracks\r\n   * @returns {Array<AudioTrack>} - The parsed audio tracks\r\n   * @private\r\n   */\r\n  _getParsedAudioTracks(): Array<AudioTrack> {\r\n    let audioTracks = this._getAudioTracks();\r\n    let parsedTracks = [];\r\n    if (audioTracks) {\r\n      for (let i = 0; i < audioTracks.length; i++) {\r\n        let settings = {\r\n          id: audioTracks[i].id,\r\n          active: audioTracks[i].active,\r\n          label: audioTracks[i].label,\r\n          language: audioTracks[i].language,\r\n          index: i\r\n        };\r\n        parsedTracks.push(new AudioTrack(settings));\r\n      }\r\n    }\r\n    return parsedTracks;\r\n  }\r\n\r\n  /**\r\n   * Get the parsed text tracks\r\n   * @function _getParsedTextTracks\r\n   * @returns {Array<TextTrack>} - The parsed text tracks\r\n   * @private\r\n   */\r\n  _getParsedTextTracks(): Array<TextTrack> {\r\n    let textTracks = this._shaka.getTextTracks();\r\n    let parsedTracks = [];\r\n    if (textTracks) {\r\n      for (let i = 0; i < textTracks.length; i++) {\r\n        let settings = {\r\n          kind: textTracks[i].kind ? textTracks[i].kind + 's' : \"\",\r\n          active: false,\r\n          label: textTracks[i].label,\r\n          language: textTracks[i].language,\r\n          index: i\r\n        };\r\n        parsedTracks.push(new TextTrack(settings));\r\n      }\r\n    }\r\n    return parsedTracks;\r\n  }\r\n\r\n  /**\r\n   * Select a video track\r\n   * @function selectVideoTrack\r\n   * @param {VideoTrack} videoTrack - the video track to select\r\n   * @returns {void}\r\n   * @public\r\n   */\r\n  selectVideoTrack(videoTrack: VideoTrack): void {\r\n    if (this._shaka) {\r\n      let videoTracks = this._getVideoTracks();\r\n      if ((videoTrack instanceof VideoTrack) && videoTracks) {\r\n        let selectedVideoTrack = videoTracks[videoTrack.index];\r\n        if (selectedVideoTrack) {\r\n          if (this.isAdaptiveBitrateEnabled()) {\r\n            this._shaka.configure({abr: {enabled: false}});\r\n            this._trigger(EventType.ABR_MODE_CHANGED, {mode: 'manual'});\r\n          }\r\n          if (!selectedVideoTrack.active) {\r\n            this._shaka.selectVariantTrack(videoTracks[videoTrack.index], true);\r\n            this._onTrackChanged(videoTrack);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Select an audio track\r\n   * @function selectAudioTrack\r\n   * @param {AudioTrack} audioTrack - the audio track to select\r\n   * @returns {void}\r\n   * @public\r\n   */\r\n  selectAudioTrack(audioTrack: AudioTrack): void {\r\n    if (this._shaka && (audioTrack instanceof AudioTrack) && !audioTrack.active) {\r\n      this._shaka.selectAudioLanguage(audioTrack.language);\r\n      this._onTrackChanged(audioTrack);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Select a text track\r\n   * @function selectTextTrack\r\n   * @param {TextTrack} textTrack - the track to select\r\n   * @returns {void}\r\n   * @public\r\n   */\r\n  selectTextTrack(textTrack: TextTrack): void {\r\n    if (this._shaka && (textTrack instanceof TextTrack) && !textTrack.active && (textTrack.kind === 'subtitles' || textTrack.kind === 'captions')) {\r\n      this._shaka.selectTextLanguage(textTrack.language);\r\n      this._onTrackChanged(textTrack);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Hide the text track\r\n   * @function hideTextTrack\r\n   * @returns {void}\r\n   * @public\r\n   */\r\n  hideTextTrack(): void {\r\n    if (this._shaka) {\r\n      this._shaka.setTextTrackVisibility(false);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enables adaptive bitrate switching\r\n   * @function enableAdaptiveBitrate\r\n   * @returns {void}\r\n   * @public\r\n   */\r\n  enableAdaptiveBitrate(): void {\r\n    if (this._shaka && !this.isAdaptiveBitrateEnabled()) {\r\n      this._trigger(EventType.ABR_MODE_CHANGED, {mode: 'auto'});\r\n      this._shaka.configure({abr: {enabled: true}});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checking if adaptive bitrate switching is enabled.\r\n   * @function isAdaptiveBitrateEnabled\r\n   * @returns {boolean} - Whether adaptive bitrate is enabled.\r\n   * @public\r\n   */\r\n  isAdaptiveBitrateEnabled(): boolean {\r\n    if (this._shaka) {\r\n      let shakaConfig = this._shaka.getConfiguration();\r\n      return shakaConfig.abr.enabled;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Returns the live edge\r\n   * @returns {number} - live edge\r\n   * @private\r\n   */\r\n  _getLiveEdge(): number {\r\n    return this._shaka ? this._shaka.seekRange().end : NaN;\r\n  }\r\n\r\n  /**\r\n   * Seeking to live edge.\r\n   * @function seekToLiveEdge\r\n   * @returns {void}\r\n   * @public\r\n   */\r\n  seekToLiveEdge(): void {\r\n    if (this._shaka) {\r\n      this._videoElement.currentTime = this._shaka.seekRange().end;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checking if the current playback is live.\r\n   * @function isLive\r\n   * @returns {boolean} - Whether playback is live.\r\n   * @public\r\n   */\r\n  isLive(): boolean {\r\n    if (this._shaka) {\r\n      return this._shaka.isLive();\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * An handler to shaka adaptation event\r\n   * @function _onAdaptation\r\n   * @returns {void}\r\n   * @private\r\n   */\r\n  _onAdaptation(): void {\r\n    let selectedVideoTrack = this._getParsedVideoTracks().filter(function (videoTrack) {\r\n      return videoTrack.active;\r\n    })[0];\r\n    this._onTrackChanged(selectedVideoTrack);\r\n  }\r\n\r\n  /**\r\n   * An handler to shaka error event\r\n   * @function _onError\r\n   * @param {any} event - the error event\r\n   * @returns {void}\r\n   * @private\r\n   */\r\n  _onError(event: any): void {\r\n    if (event && event.detail) {\r\n      const error = event.detail;\r\n      //don't handle video element errors, they are already handled by the player\r\n      if (error.code === this.VIDEO_ERROR_CODE) {\r\n        return;\r\n      }\r\n      this._trigger(EventType.ERROR,\r\n        new Error(\r\n          error.severity,\r\n          error.category,\r\n          error.code,\r\n          error.data));\r\n      DashAdapter._logger.error(error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * An handler to shaka buffering event\r\n   * @function _onBuffering\r\n   * @param {any} event - the buffering event\r\n   * @returns {void}\r\n   * @private\r\n   */\r\n  _onBuffering(event: any): void {\r\n    if (event.buffering) {\r\n      if (!this._waitingSent) {\r\n        // The player enters the buffering state and 'waiting' event hasn't been sent by the HTMLVideoElement.\r\n        this._videoElement.dispatchEvent(new window.Event(EventType.WAITING));\r\n        this._buffering = true;\r\n      }\r\n    } else {\r\n      this._buffering = false;\r\n      if (!this._videoElement.paused && !this._playingSent) { //the player leaves the buffering state. and 'playing' event hasn't been sent by the HTMLVideoElement.\r\n        this._videoElement.dispatchEvent(new window.Event(EventType.PLAYING));\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * An handler to HTMLVideoElement waiting event\r\n   * @function _onWaiting\r\n   * @returns {void}\r\n   * @private\r\n   */\r\n  _onWaiting(): void {\r\n    this._waitingSent = true;\r\n    this._playingSent = false;\r\n  }\r\n\r\n  /**\r\n   * An handler to HTMLVideoElement playing event\r\n   * @function _onPlaying\r\n   * @returns {void}\r\n   * @private\r\n   */\r\n  _onPlaying(): void {\r\n    this._playingSent = true;\r\n    this._waitingSent = false;\r\n    if (this._buffering) {\r\n      // The player is in buffering state.\r\n      this._videoElement.dispatchEvent(new window.Event(EventType.WAITING));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the start time of DVR window in live playback in seconds.\r\n   * @returns {Number} - start time of DVR window.\r\n   * @public\r\n   */\r\n  getStartTimeOfDvrWindow(): number {\r\n    if (this.isLive() && this._shaka) {\r\n      return this._shaka.seekRange().start;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./dash-adapter.js","// @flow\r\nimport {BaseDrmProtocol, Env} from 'pakhshkit-js'\r\n\r\nconst DrmSupport = BaseDrmProtocol.DrmSupport;\r\nconst DrmScheme = BaseDrmProtocol.DrmScheme;\r\n\r\nexport default class Widevine extends BaseDrmProtocol {\r\n  static _logger = BaseDrmProtocol.getLogger('Widevine');\r\n\r\n  /**\r\n   * Widevine playback supports in case 2 conditions are met:\r\n   * 1. The environment supports Widevine playback.\r\n   * 2. The drm data of the source object contains entry with Widevine scheme.\r\n   * @param {Array<Object>} drmData - The drm data to check.\r\n   * @return {boolean} - Whether FairPlay can be play on the current environment.\r\n   */\r\n  static canPlayDrm(drmData: Array<Object>): boolean {\r\n    Widevine._logger.debug(\"Can play DRM scheme of: \" + DrmScheme.WIDEVINE);\r\n    return DrmSupport.isProtocolSupported(DrmScheme.WIDEVINE, drmData);\r\n  }\r\n\r\n  /**\r\n   * Sets the Widevine playback.\r\n   * @param {Object} config - The shaka player config.\r\n   * @param {Array<Object>} drmData - The drm data.\r\n   * @returns {void}\r\n   */\r\n  static setDrmPlayback(config: Object, drmData: Array<Object>): void {\r\n    Widevine._logger.debug(\"Sets drm playback\");\r\n    let browser = Env.browser.name;\r\n    let wwDrmEntry = drmData.find((drmEntry) => drmEntry.scheme === DrmScheme.WIDEVINE);\r\n    if (wwDrmEntry) {\r\n      config.drm = {\r\n        servers: {\r\n          [DrmScheme.WIDEVINE]: wwDrmEntry.licenseUrl\r\n        },\r\n        advanced: {}\r\n      };\r\n      if (browser === 'Chrome') {\r\n        config.drm.advanced = {\r\n          [DrmScheme.WIDEVINE]: {\r\n            'videoRobustness': 'SW_SECURE_CRYPTO',\r\n            'audioRobustness': 'SW_SECURE_CRYPTO'\r\n          }\r\n        };\r\n      }\r\n    }\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./drm/widevine.js","// @flow\r\nimport {BaseDrmProtocol} from 'pakhshkit-js'\r\n\r\nconst DrmSupport = BaseDrmProtocol.DrmSupport;\r\nconst DrmScheme = BaseDrmProtocol.DrmScheme;\r\n\r\nexport default class PlayReady extends BaseDrmProtocol {\r\n  static _logger = BaseDrmProtocol.getLogger('PlayReady');\r\n\r\n  /**\r\n   * PlayReady playback supports in case 2 conditions are met:\r\n   * 1. The environment supports PlayReady playback.\r\n   * 2. The drm data of the source object contains entry with PlayReady scheme.\r\n   * @param {Array<Object>} drmData - The drm data to check.\r\n   * @return {boolean} - Whether FairPlay can be play on the current environment.\r\n   */\r\n  static canPlayDrm(drmData: Array<Object>): boolean {\r\n    PlayReady._logger.debug(\"Can play DRM scheme of: \" + DrmScheme.PLAYREADY);\r\n    return DrmSupport.isProtocolSupported(DrmScheme.PLAYREADY, drmData);\r\n  }\r\n\r\n  /**\r\n   * Sets the PlayReady playback.\r\n   * @param {Object} config - The shaka player config.\r\n   * @param {Array<Object>} drmData - The drm data.\r\n   * @returns {void}\r\n   */\r\n  static setDrmPlayback(config: Object, drmData: Array<Object>): void {\r\n    PlayReady._logger.debug(\"Sets drm playback\");\r\n    let prDrmEntry = drmData.find((drmEntry) => drmEntry.scheme === DrmScheme.PLAYREADY);\r\n    if (prDrmEntry) {\r\n      config.drm = {\r\n        servers: {\r\n          [DrmScheme.PLAYREADY]: prDrmEntry.licenseUrl\r\n        }\r\n      };\r\n    }\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./drm/playready.js","module.exports = {\"streaming\":{\"ignoreTextStreamFailures\":true}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./default-config.json\n// module id = 6\n// module chunks = 0","// @flow\r\nimport shaka from 'shaka-player';\r\n\r\n/**\r\n * shaka doesn't handle hidden caption see https://github.com/google/shaka-player/issues/1058.\r\n * This stops us to handle the caption by ourself by setting the native caption hidden.\r\n * So we have to override the shaka text displayer to cause shaka handles hidden caption.\r\n */\r\nexport default class TextDisplayer extends shaka.text.SimpleTextDisplayer {\r\n  /**\r\n   *\r\n   * @return {boolean} - isTextVisible\r\n   */\r\n  isTextVisible(): boolean {\r\n    return true;\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./text-displayer.js"],"sourceRoot":""}